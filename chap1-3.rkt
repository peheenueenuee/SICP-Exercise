
(define (id x) x)
(define (square x) (* x x))
(define (cube x) (* x x x))
(define (dec n) (- n 1))
(define (inc n) (+ n 1))
(define (average a b) (/ (+ a b) 2))
(define (pow a n)
  (cond ((= n 0) 1)
        ((even? n) (square (pow a (/ n 2))))
        (else (* a (pow a (dec n))))))

;(1.29)
;(1.30)
;(1.32)
(define (accumulate conbiner id-value term a next b)
  (define (iter x result)
	(if (> x b)
	  result
	  (iter (next x) (conbiner result (term x)))))
  (iter a id-value))

(define (sum term a next b)
  (accumulate + 0 term a next b))
(define (product term a next b)
  (accumulate * 1 term a next b))

(define (pi-sum a b)
  (define (pi-term x)
	(/ 1.0 (* x (+ x 2))))
  (define (next n)
	(+ n 4))
  (sum pi-term a next b))
(define (integral f a b dx)
  (define (add-dx x)
	(+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b) dx))

(define (simpson f a b n)
  (define h (/ (- b a) n))
  (define (y k)
	(define y-term (f (+ a (* k h))))
	(cond ((or (= k 0) (= k n)) y-term)
		  ((even? k) (* 2.0 y-term))
		  (else (* 4.0 y-term))))
  (define sum-y (sum y 0 inc n))
  (* sum-y (/ h 3.0)))

;(1.31)
(define (factorial n)
  (product id 1 inc n))
(define (pi-product n)
  (define (pi-term x)
	(define xt (* 2 x))
	(/ (square xt) (square (inc xt))))
  (/ (* 2.0 2.0 n (product pi-term 2.0 inc n)) 9.0))

;(1.33)
(define (filterd-accumulate conbiner id-value filterf term a next b)
  (define (iter x result)
    (if (> x b)
        result
        (if (filterf x) (iter (next x) (conbiner result (term x)))
            (iter (next x) result))))
  (iter a id-value))

(define (expmod-mr base expe m)
  (cond ((= expe 0) 1)
        ((even? expe)
         (remainder
          (square (expmod-mr base (/ expe 2) m))
          m))
        (else
         (remainder
          (* base (expmod-mr base (dec expe) m)) 
          m))))
(define (miller-rabin-test n)
  (define (try-it a)
    (= (expmod-mr a (dec n) n) 1))
  (try-it (inc (random (dec n)))))
(define (fast-prime-mr? n times)
  (cond ((= times 0) true)
        ((miller-rabin-test n) (fast-prime-mr? n (dec times)))
        (else false)))
(define (prime? n)
  (fast-prime-mr? n 20))

(define (mygcd a b)
  (define (gcd-loop gtn ltn k)
    (if (= ltn 0) gtn
        (gcd-loop ltn (remainder gtn ltn) (+ 1 k))))
  (if (> a b) (gcd-loop a b 1)
      (gcd-loop b a 1)))

(define (coprime? a b)
  (= 1 (mygcd a b)))

(define (products-lt-coprime n)
  (define (coprime-with-n? x) (coprime? n x))
  (filterd-accumulate * 1 coprime-with-n? id 2 inc n))

;(1.34)
;(1.36)
(define tolerance 0.000001)
(define (fixed-point f first-guess)
  (define (try guess)
   (define (close-enough? v1 v2) (< (abs (- v1 v2)) tolerance))
   (newline)
   (display guess)
   (let ((next (f guess)))
   (if (close-enough? guess next)
       next
       (try next))))
  (try first-guess))

;(fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0) ;phi
;(/ (+ 1 (sqrt 5)) 2) ;phi

;(1.35)
;(fixed-point (lambda (x) (/ (log 1000) (log x))) 30.0)

;(1.37)
(define (cont-frac ni di i k)
  (let ((n (ni i))
        (d (di i)))
    (if (= k i) (/ n d)
        (/ n (+ d (cont-frac ni di (inc i) k))))))

(define (cont-frac-iter n d k)
  (define (iter result times)
    (let ((next (/ n (+ d result))))
      (if (= times 1) next
          (iter next (dec times)))))
  (iter (/ n d) k))

;(cont-frac (lambda (i) 1.0)
;           (lambda (i) 1.0)
;           1 100)
;(cont-frac-iter 1.0 1.0 100)

;(1.38)
(define (di n k)
  (define (iter i)
    (if (=  2 (remainder i 3)) (* 2 (inc (quotient i 3)))
        1))
  (newline)
  (display (iter n))
  (if (= k 1) (newline)
      (di (inc n) (dec k))))

(define (euler-napier k)
  (define (di i)
    (if (= 2 (remainder i 3))
                  (* 2.0 (inc (quotient i 3.0)))
                  1.0))
  (cont-frac (lambda (i) 1.0)
             di
             1
             k))

;(1.39)
(define (lambert-tan x k)
  (define (ni i)
    (if (= i 1) x
        (- (square x))))
  (define (di i)
    (dec (* 2.0 i)))
  (cont-frac ni di 1 k))

;(1.40)
(define (deriv g)
  (let ((dx 0.000001))
    (lambda (x) (/ (- (g (+ x dx)) (g x))
                   dx))))
(define (newton-transform g)
  (lambda (x) (- x (/ (g x)
                      ((deriv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

(define (cubic a b c)
  (lambda (x) (+ (cube x)
                 (* a (square x))
                 (* b x)
                 c)))

;(1.41)
(define (double-apply f)
  (lambda (x) (f (f x))))
;(1.42)
(define (compose f g)
  (lambda (x) (f (g x))))
;(1.43)
(define (repeated f n)
  (if (or (< n 1) (= n 1)) (lambda (x) (f x))
      (compose f (repeated f (dec n)))))
;(1.44)
(define (smooth f)
  (let ((dx 0.000001))
    (define (next x) (+ x dx))
    (define (prev x) (- x dx))
    (lambda (x) (/ (+ (f x) (f (next x)) (f (prev x))) 3))))

;(1.45)
(define (average-damp f)
  (lambda (x) (average x (f x))))

(define (sq-root x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
(define (cube-root x)
  (fixed-point (average-damp (lambda (y) (/ x (square y))))
               1.0))

(define (n-power-root n x)
  (define (average-repeat-iter m k)
    (if (< m (pow 2 k)) k
           (average-repeat-iter m (inc k))))
  (define average-repeat
    (average-repeat-iter n 1))
  (fixed-point ((repeated average-damp average-repeat)
                (lambda (y) (/ x (pow y (dec n)))))
               1.0))
