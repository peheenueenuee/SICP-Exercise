(load "number.rkt")

(define (dec n) (- n 1))
(define (inc n) (+ n 1))
;(2.17)
(define (last-pair-of-xs xs)
  (if (null? (cdr xs)) (car xs) (last-pair-of-xs (cdr xs))))
;(2.18)
(define (reversing xs)
  (define (iter normal revers)
    (if (null? normal) revers
        (iter (cdr normal) (cons (car normal) revers))))
  (iter xs null))

;(2.19)
(define us-coin (list 50 25 1 5 10))
(define uk-coin (list 0.5 1 2 5 10 20 50 100))
(define jp-coin (list 1 5 10 50 100 500))

(define (cc remain-amount kinds-of-coin)
  (cond ((= remain-amount 0) 1)
        ((or (< remain-amount 0) (null? kinds-of-coin)) 0)
        (else (+ (cc remain-amount (cdr kinds-of-coin))
                 (cc (- remain-amount (car kinds-of-coin)) kinds-of-coin)))))

;(2.20)
(define (same-parity x . xs)
  (define (parity-filtered-list fil? ls)
    (if (null? ls) null
        (if (fil? (car ls))
            (cons (car ls) (parity-filtered-list  fil? (cdr ls)))
            (parity-filtered-list fil? (cdr ls)))))
  (if (even? x) (cons x (parity-filtered-list even? xs))
      (cons x (parity-filtered-list odd? xs))))

;(2.21)
;(2.30)
;(2.31)
(define (square-list1 items)
  (if (null? items) null
      (cons ((lambda (x) (* x x)) (car items))
            (square-list1 (cdr items)))))
(define (square-list2 items)
  (map (lambda (x) (* x x)) items))

(define (square-tree-nomap tree)
  (cond ((null? tree) null)
        ((pair? (car tree)) (cons (square-tree-nomap (car tree))
                                  (square-tree-nomap (cdr tree))))
        (else (cons ((lambda (x) (* x x)) (car tree))
                    (square-tree-nomap (cdr tree))))))
(define (tree-map proc tree)
  (map (lambda (x) (cond ((null? x) null)
                         ((pair? x) (tree-map proc x))
                         (else (proc x))))
       tree))
(define (square-tree tree) (tree-map (lambda (x) (* x x)) tree))

;(2.22)
; by Louis Reasoner
(define (square-list-rev items)
  (define (iter things answer)
    (if (null? things) answer
        (iter (cdr things)
              (cons ((lambda (x) (* x x)) (car things)) answer))))
  (iter items null))

(define (square-list-recur items)
  (define (iter things answer)
    (if (null? things) answer
        (iter (cdr things)
              (cons answer
                    ((lambda (x) (* x x)) (car things))))))
  (iter items null))

;(2.23)
(define (my-for-each proc xs)
  (cond ((null? xs) null)
        (else (proc (car xs))
              (my-for-each proc (cdr xs)))))

;(2.24)
(define list224 (list 1 (list 2 (list 3 4))))
;(2.26)
(define list226x (list 1 2 3))
(define list226y (list 4 5 6))

;(2.27)
(define (deep-reverse xs)
  (define (iter items result)
    (cond ((null? items) result)
          ((pair? (car items))
                  (iter (cdr items)
                        (cons (iter (car items) null)
                              result)))
          (else (iter (cdr items) (cons (car items) result)))))
  (iter xs null))

;(2.28)
(define (fringe xs)
  (define (iter items result)
    (cond ((null? items) result)
          ((pair? (car items))
           (iter (cdr items)
                 (append result (iter (car items) null))))
          (else (iter (cdr items) (append result (list (car items)))))))
  (iter xs null))



;(2.29)
; play you a funny mobile
(define (make-mobile left right)
  (cons left right))
(define (make-branch branch-length structure)
  (cons branch-length structure))
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cdr branch))

(define (total-weight mobile)
  (+ (branch-weight (left-branch mobile))
     (branch-weight (right-branch mobile))))
(define (branch-weight branch)
  (let ((wt (branch-structure branch)))
    (if (pair? wt) (total-weight wt) wt)))

(define (balanced? mobile)
  (= (* (branch-weight (left-branch mobile))
        (branch-length (left-branch mobile)))
     (* (branch-weight (right-branch mobile))
        (branch-length (right-branch mobile)))))

(define mobA (make-mobile (make-branch 3.0 10.0) (make-branch 2.0 8.0)))
(define mobB (make-mobile (make-branch 5.0 15.0) (make-branch 3.0 mobA)))
(define mobC (make-mobile (make-branch 2.0 mobA) (make-branch 2.0 mobA)))
(define mobD (make-mobile (make-branch 2.0 5.0) (make-branch 5.0 2.0)))

;(2.32)
(define (subsets s)
  (if (null? s) (list null)
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (cons (car s) x)) rest)))))

;(2.33)
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(define (my-map p sequence)
  (accumulate (lambda (x y) (cons (p x) y))
              null
              sequence))
(define (my-append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (my-length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))

;(2.34)
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                (+ this-coeff (* x higher-terms)))
              0
              coefficient-sequence))
;(2.35)
(define (count-leaves tree)
  (accumulate (lambda (x rightside)
                (cond ((pair? x) (+ rightside (count-leaves x)))
                      (else (+ 1 rightside))))
              0
              tree))
;(2.36)
(define (accumulate-n op init seqs)
  (if (null? (car seqs)) null
             (cons (accumulate op init (map car seqs))
                   (accumulate-n op init (map cdr seqs)))))
;(2.38)
(define (fold-left op initial sequence)
  (define (iter result restseq)
    (if (null? restseq) result
        (iter (op result (car restseq)) (cdr restseq))))
  (iter initial sequence))
(define (fold-right op initial sequence) (accumulate op initial sequence))

;(2.39)
(define (reverse-by-foldl seq)
  (fold-left (lambda (x y) (cons y x)) null seq))
(define (reverse-by-foldr seq)
  (fold-right (lambda (x y) (append y (list x))) null seq))

(define (pairlist n)
  (accumulate append null
   (map (lambda (i)
          (map (lambda (j)
                 (list i j))
               (ennumerate-interval 1 (dec i))))
        (ennumerate-interval 1 n))))

(define (flatmap proc seq)
  (accumulate append null (map proc seq)))
(define (pairlist2 n)
  (flatmap (lambda (i)
             (map (lambda (j)
                    (list i j))
                  (ennumerate-interval 1 (dec i))))
           (ennumerate-interval 1 n)))
(define (pairlist3 n)
  (map (lambda (i)
             (map (lambda (j)
                    (list i j))
                  (ennumerate-interval 1 (dec i))))
           (ennumerate-interval 1 n)))

(define (remove item s)
  (filter (lambda (x) (not (= x item))) s))
(define (permutations s)
  (if (null? s) (list null)
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
;(2.40)
(define (unique-pairs n) (pairlist2 n))
(define (prime-sum-pairs n)
  (let ((p-list (unique-pairs n))
        (p-sum (lambda (pair) (+ (car pair) (cadr pair)))))
    (map (lambda (p) (append p (p-sum p)))
         (filter (lambda (p) (prime? (p-sum p)))
                 p-list))))
;(2.41)
(define (triple-list n)
  (let ((num-list (ennumerate-interval 1 n)))
    (flatmap (lambda (i)
               (flatmap (lambda (j)
                          (map (lambda (k) (list i j k))
                               (filter (lambda (x) (=< j x)) num-list)))
                        (filter (lambda (x) (=< i x)) num-list)))
             num-list)))
(define (taple-list order n)
  (define (taple-list-iter current-order current-n former-taple)
    (let ((num-list (ennumerate-interval 1 n)))
      (if (=< current-order 1)
          (map (lambda (k) (cons k former-taple))
               (filter (lambda (x) (=< current-n x)) num-list))
          (flatmap (lambda (i)
                     (taple-list-iter (dec current-order)
                                      i
                                      (cons i former-taple)))
                   (filter (lambda (x) (=< current-n x)) num-list)))))
  (taple-list-iter order 1 null))

(define (find-sum-in-ntaple sum order n)
  (filter (lambda (t) (= sum (accumulate + 0 t)))
          (taple-list order n)))

;(2.42)
(define (queens board-size)
  (define (safe? col positions)
    (define (same-row-or-col? p1 p2)
      (or (= (car p1) (car p2)) (= (cadr p1) (cadr p2))))
    (define (same-col? p)
      (= col (cadr p)))
    (if (< (length positions) 2) false
        (not (same-col? (cadr positions)))))
  (let ((row-list (ennumerate-interval 1 board-size))
        (empty-board null)
        (adjoin-position (lambda (row col roq) (cons (list row col) roq))))
    (define (queen-cols k)
      (if (=< k 0)
          (list empty-board)
          (filter (lambda (positions) (safe? k positions))
                  (flatmap (lambda (rest-of-Q)
                             (map (lambda (new-row)
                                    (adjoin-position new-row k rest-of-Q))
                                  row-list))
                           (queen-cols (dec k))))))
    (queen-cols board-size)))
